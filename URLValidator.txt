Daniel Bonnin
Victor Hernandez
Billy Kerns

CS362: Final Project, Part B

************************************************************************************
This file contains bug reports and documentation of the testing we performed for 
part B of the final project.

Manual testing URLS (interesting subset)

How did we partition the inputs?

Names of Tests:

How did we collaborate?:


Bug report 1:
Name:     
  Valid country domains failing validation.
File:  
  DomainValidator.java
Severity:       
  MEDIUM
Priority:
  MEDIUM  
Reported Date:
  25NOV2015
Reason:    
  Countries missing from COUNTRY_CODE_TLD in DomainValidator.java
Status:         
  OPEN
Description:
  All countries after Italy (alphabetically) are omitted from COUNTRY_CODE_TLD array.
Steps to Reproduce: 
  Call isValidAuthority("www.msn.<countryCode>"); where countryCode is
  the top level domain for any country after Italy alphabetically. 
Expected Results:   
  Should return true, but will return false. 
Debugging details:
  Manual testing revealed this bug. One of the partitions obvious to our
  team was the top-level domain since they are many and often are obscure.
  Used the eclipse debugger to localize the fault to isValidCountryCodeTld(), 
  which references the COUNTRY_CODE_TLD array. 
  
  
Bug report 2:
Name: 
  Valid query causes false invalid
File:  
  UrlValidator.java
Severity:       
  HIGH
Priority:
  High
Reported Date:
  27NOV2015
Reason:    
  isValidQuery() boolean return value is negated to opposite value.
Status:         
  Open
Description:
  Query regex pattern matches nothing. Only returns true on empty query.
Steps to Reproduce: 
  call isValid("http://www.google.com:22/test1?action=view");
Expected Results:   
  Should return true.
Debugging details:
  We tested known correct/incorrect queries appended to known correct
  URL strings on the isValid() function as part of testing the query
  partition of URLs. 
  
  We only found this bug due to isValid() failing with known 
  correct queries. 
  
  Using reserved characters as test negative query strings was 
  problematic. The URL regex will process the query as part of
  the path unless its first character is a '?'. Also, the regex for 
  checking query strings in URLValidator matches all characters except 
  newline, so it does not reject reserved characters.
  
  It took a code inspection to localize the fault to this line
  in URLValidator.java: return !QUERY_PATTERN.matcher(query).matches();
  
  Removing the negation operator fixed the bug, though incorrect 
  queries are still interpreted as part of the path if the '?' is
  omitted. 
  

Bug report 3:
Name: 
  Port numbers higher than 99 are invalidated          
File:  
  UrlValidator.java
Severity:
  MEDIUM
Priority:
  MEDIUM  
Reported Date:
  28NOV2015
Reason:    
  PORT_REGEX invalides port numbers with > 3 digits.
Status:         
  Open
Description:
  The isValidAuthority() function returns false 
  due to PORT_REGEX failing to match > 3 digits.
Steps to Reproduce: 
  Call UrlValidator.isValid("http://www.amazon.com:2222");
Expected Results:   
  Should return true. Current bug results in this returning false.
Debugging details:
  In our test of the port "partition", we established the 
  upper boundary of port numbers as the max 16 bit unsigned int, 
  which is 65535. 
  
  It seemed that the length of the port string was the issue. 
  
  Using the Eclipse debugger, we localized the fault to 
  the PORT_REGEX on line 158 of UrlValidator.java, which
  enforces a maximum of 3 digits. 
  
  Correcting this regex to allow 5 digits would validate
  all valid ports, but also permit some false positives
  (eg. 65535 < portNum < 99999). 
  
  This may or may not be out of scope for our concerns, 
  however. 
  
  
